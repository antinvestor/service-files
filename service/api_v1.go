/*
 * Ant Investor Files
 *
 * An openAPI 3.0 specification that defines how files are stored and accessed on ant investor products
 *
 * API version: 1.0.0
 * Contact: info@antinvestor.com
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package service

import (
	"encoding/json"
	"io/ioutil"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/Sirupsen/logrus"
	"github.com/gorilla/mux"
	"github.com/jinzhu/gorm"
	"github.com/thedevsaddam/govalidator"
	"errors"
	"bytes"
	"fmt"
	"bitbucket.org/antinvestor/service-file/openapi"
	"bitbucket.org/antinvestor/service-file/utils"
	"bitbucket.org/antinvestor/service-file/service/storage"
	"github.com/opentracing/opentracing-go"
	otgorm "github.com/smacker/opentracing-gorm"
	"context"
	"github.com/opentracing/opentracing-go/ext"
)

// Env Context object supplied around the applications lifetime
type Env struct {
	db              *gorm.DB
	Logger          *logrus.Entry
	ServerPort	string
	EncryptionPhrase string
	FileAccessServer string
	StrorageProvider storage.Provider
}

func (env *Env) SetDb(db *gorm.DB) {
	env.db = db
}

func (env *Env) GetDb(ctx context.Context) *gorm.DB{
	return otgorm.SetSpanToGorm(ctx, env.db)
}

// Logger -
func Logger(inner http.Handler, name string, logger *logrus.Entry) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		start := time.Now()

		inner.ServeHTTP(w, r)

		logger.Printf(
			"%s %s %s %s",
			r.Method,
			r.RequestURI,
			name,
			time.Since(start),
		)
	})
}

func addHandler(env *Env, router *mux.Router,
	f func(env *Env, w http.ResponseWriter, r *http.Request) error , path string, name string, method string) {

	handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {

		err := f(env, w, r)
		if err != nil {
			switch e := err.(type) {
			case Error:
				// We can retrieve the status here and write out a specific
				// HTTP status code.
				env.Logger.Warnf("request failed with  %d - %s", e.Status(), e)
				http.Error(w, e.Error(), e.Status())
			default:

				env.Logger.Error(e)
				// Any error types we don't specifically look out for default
				// to serving a HTTP 500
				http.Error(w, http.StatusText(http.StatusInternalServerError),
					http.StatusInternalServerError)
			}
		}

	})
	loggedHandler := Logger(handler, name, env.Logger)

	router.Methods(method).
		Path(path).
		Name(name).
		Handler(loggedHandler)

}

// NewRouterV1 -
func NewRouterV1(env *Env) *mux.Router {
	router := mux.NewRouter().StrictSlash(true)

	addHandler(env, router, AddFileV1, "/files", "AddFile", "POST")
	addHandler(env, router, FindFilesV1, "/files", "FindFiles", "GET")
	addHandler(env, router, FindFileByIDV1, "/files/{id}", "FindFileById", "GET")
	addHandler(env, router, DeleteFileV1, "/files/{id}", "DeleteFile", "DELETE")

	return router
}

// AddFileV1 -
func AddFileV1(env *Env, w http.ResponseWriter, r *http.Request) error {

	span, ctx := opentracing.StartSpanFromContext(r.Context(), "AddFileV1")
	defer span.Finish()


	rules := govalidator.MapData{
		"group_id":        []string{"required", "max:30"},
		"subscription_id": []string{"required", "max:30"},
		"public":          []string{"bool"},
		"file:fileObject": []string{"ext:jpeg,jpg,png", "size:100000000", "required"},
	}

	messages := govalidator.MapData{
		"group_id":        []string{"required: A group ID should be provided", "max:ID values should not be more than 30 characters in length"},
		"subscription_id": []string{"required: A subscription ID should be provided", "max:ID values should not be more than 30 characters in length"},
		"file:fileObject": []string{"ext:Only jpg/png files are allowed", "required:A file object is required"},
	}

	opts := govalidator.Options{
		Request:         r,        // request object
		Rules:           rules,    // rules map
		Messages:        messages, // custom message map (Optional)
		RequiredDefault: true,     // all the field to be pass the rules
	}
	validator := govalidator.New(opts)

	e := validator.Validate()
	if len(e) != 0 {
		err, _ := json.Marshal(e)
		return  StatusError{400, errors.New(string(err))}
	}
	if err := r.ParseMultipartForm(262144); err != nil {
		return  StatusError{400, err}
	}

	file, header, err := r.FormFile("fileObject")
	if err != nil {
		return  StatusError{400, err}
	}

	contents, _ := ioutil.ReadAll(file)


	// Use the net/http package's handy DectectContentType function. Always returns a valid
	// content-type by returning "application/octet-stream" if no others seemed to match.
	contentType := http.DetectContentType(contents)

	// TODO: obtain the subscription id from authentication data
	subscriptionID := r.FormValue("subscription_id")
	groupID := r.FormValue("group_id")
	public, _ := strconv.ParseBool(r.FormValue("public"))

	hash := CreateHash(contents)

	extParts := strings.Split(header.Filename, ".")
	extension := extParts[len(extParts)-1]



	bucket, result, err := FileUpload(env, span, public, subscriptionID, hash, extension, contents)
	if err != nil {
		ext.Error.Set(span, true) // Tag the span as errored
		span.LogKV("Error on file upload", err)
		return  StatusError{500, err}
	}

	newFile := File{
		Name:           header.Filename,
		GroupID:        groupID,
		SubscriptionID: subscriptionID,
		Public:         public,
		Hash:           hash,
		Mimetype:       contentType,
		Ext:            extension,
		Size:           header.Size,
		BucketName:     bucket,
		Provider:       env.StrorageProvider.Name(),
		UploadResult: result,
	}


	if err := env.GetDb(ctx).Create(&newFile).Error; err != nil {
		return  StatusError{500, err}
	}

	response, _ := json.Marshal(newFile.ToApi(env))

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusCreated)
	w.Write(response)
	return nil

}

// DeleteFileV1 -
func DeleteFileV1(env *Env, w http.ResponseWriter, r *http.Request) error {

	span, ctx := opentracing.StartSpanFromContext(r.Context(), "DeleteFileV1")
	defer span.Finish()


	pathVars := mux.Vars(r)

	file := File{
		FileID: pathVars["id"],
	}


	if err := env.GetDb(ctx).First(&file).Error; err != nil {
		return  StatusError{500, err}
	}

	if err := env.GetDb(ctx).Delete(&file).Error; err != nil {
		return  StatusError{500, err}
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusAccepted)
	return nil
}

// FindFileByIDV1 -
func FindFileByIDV1(env *Env, w http.ResponseWriter, r *http.Request)error {

	span, ctx := opentracing.StartSpanFromContext(r.Context(), "FindFileByIDV1")
	defer span.Finish()

	pathVars := mux.Vars(r)

	file := File{
		FileID: pathVars["id"],
	}


	if err := env.GetDb(ctx).First(&file).Error; err != nil {
		env.Logger.Warn(err)
	}

	fileContent, err := FileDownload(env, span, file)
	if err != nil {
		ext.Error.Set(span, true) // Tag the span as errored
		span.LogKV("Error on file download", err)

		return  StatusError{500, err}
	}

	go func() {

		auditRecord := AuditFile{
			FileID: file.FileID,
			SubscriptionID: "Authenticated ID",
			Source: utils.GetIp(r),
			Action: "View",

		}
		env.GetDb(ctx).Create(&auditRecord)
	}()

	w.Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=%s", file.Name))
	w.Header().Set("Content-Type", file.Mimetype)
	http.ServeContent(w, r, file.Name, file.CreatedAt, bytes.NewReader(fileContent))
	return nil
}

// FindFilesV1 -
func FindFilesV1(env *Env, w http.ResponseWriter, r *http.Request) error{

	span, ctx := opentracing.StartSpanFromContext(r.Context(), "FindFilesV1")
	defer span.Finish()

	var matchingFiles []File

	subscriptionID := r.FormValue("subscription_id")
	groupID := r.FormValue("group_id")
	page := r.FormValue("page")
	limit := r.FormValue("limit")

	tx := env.GetDb(ctx).Where("subscription_id = ?", subscriptionID)

	if groupID != ""{
		tx = tx.Where("group_id = ?", groupID)
	}

	if page != ""{
		tx = tx.Offset(page)
	}

	if limit != ""{
		tx = tx.Limit(limit)
	}

	tx.Find(&matchingFiles)

	apiFiles := make([]openapi.File, len(matchingFiles))


	for i, file := range matchingFiles{
		apiFiles[i] = file.ToApi(env)
	}

	response, _ := json.Marshal(apiFiles)

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	w.Write(response)
	return nil
}
