/*
 * Ant Investor Files
 *
 * An openAPI 3.0 specification that defines how files are stored and accessed on ant investor products
 *
 * API version: 1.0.0
 * Contact: info@antinvestor.com
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package service

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/antinvestor/files/config"
	"github.com/antinvestor/files/openapi"
	models2 "github.com/antinvestor/files/service/models"
	"github.com/antinvestor/files/service/storage"
	"github.com/gorilla/mux"
	"github.com/pitabwire/frame"
	"github.com/thedevsaddam/govalidator"
	"io/ioutil"
	"log"
	"net/http"
	"strconv"
	"strings"
)


// AddFileV1 -
func AddFileV1(w http.ResponseWriter, r *http.Request) error {

	ctx := r.Context()
	service := frame.FromContext(ctx)


	rules := govalidator.MapData{
		"group_id":        []string{"required", "max:30"},
		"subscription_id": []string{"required", "max:30"},
		"public":          []string{"bool"},
		"file:fileObject": []string{"ext:jpeg,jpg,png", "size:100000000", "required"},
	}

	messages := govalidator.MapData{
		"group_id":        []string{"required: A group ID should be provided", "max:ID values should not be more than 30 characters in length"},
		"subscription_id": []string{"required: A subscription ID should be provided", "max:ID values should not be more than 30 characters in length"},
		"file:fileObject": []string{"ext:Only jpg/png files are allowed", "required:A file object is required"},
	}

	opts := govalidator.Options{
		Request:         r,        // request object
		Rules:           rules,    // rules map
		Messages:        messages, // custom message map (Optional)
		RequiredDefault: true,     // all the field to be pass the rules
	}
	validator := govalidator.New(opts)

	e := validator.Validate()
	if len(e) != 0 {
		err, _ := json.Marshal(e)
		return StatusError{400, errors.New(string(err))}
	}
	if err := r.ParseMultipartForm(262144); err != nil {
		return StatusError{400, err}
	}

	file, header, err := r.FormFile("fileObject")
	if err != nil {
		return StatusError{400, err}
	}

	contents, _ := ioutil.ReadAll(file)

	// Use the net/http package's handy DectectContentType function. Always returns a valid
	// content-type by returning "application/octet-stream" if no others seemed to match.
	contentType := http.DetectContentType(contents)

	// TODO: obtain the subscription id from authentication data
	subscriptionID := r.FormValue("subscription_id")

	groupID := r.FormValue("group_id")
	public, _ := strconv.ParseBool(r.FormValue("public"))

	hash := CreateHash(contents)

	extParts := strings.Split(header.Filename, ".")
	extension := extParts[len(extParts)-1]

	bucket, result, err := FileUpload(ctx, public, subscriptionID, hash, extension, contents)
	if err != nil {
		return StatusError{500, err}
	}

	storageProvider := ctx.Value(config.CtxStorageProviderKey).(storage.Provider)

	newFile := models2.File{
		Name:           header.Filename,
		GroupID:        groupID,
		SubscriptionID: subscriptionID,
		Public:         public,
		Hash:           hash,
		Mimetype:       contentType,
		Ext:            extension,
		Size:           header.Size,
		BucketName:     bucket,
		Provider:       storageProvider.Name(),
		UploadResult:   result,
	}

	if err := service.DB(ctx, false).Create(&newFile).Error; err != nil {
		return StatusError{500, err}
	}

	fileAccessServer := frame.GetEnv("FILE_ACCESS_SERVER_URL", "")

	response, _ := json.Marshal(newFile.ToApi(fileAccessServer))

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusCreated)
	_, err = w.Write(response)
	if err != nil {
		return StatusError{500, err}
	}
	return nil

}

// DeleteFileV1 -
func DeleteFileV1(w http.ResponseWriter, r *http.Request) error {
	ctx := r.Context()
	service := frame.FromContext(ctx)

	pathVars := mux.Vars(r)

	file := models2.File{}

	if err := service.DB(ctx, true).First(&file, pathVars["id"]).Error; err != nil {
		return StatusError{500, err}
	}

	if err := service.DB(ctx, false).Delete(&file, pathVars["id"]).Error; err != nil {
		return StatusError{500, err}
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusAccepted)
	return nil
}

// FindFileByIDV1 -
func FindFileByIDV1(w http.ResponseWriter, r *http.Request) error {
	ctx := r.Context()
	service := frame.FromContext(ctx)

	pathVars := mux.Vars(r)

	file := models2.File{}

	if err := service.DB(ctx, true).First(&file, pathVars["id"]).Error; err != nil {
		log.Printf("Could not find entry : %v", err)
	}

	fileContent, err := FileDownload(ctx, file)
	if err != nil {
		return StatusError{500, err}
	}

	go func() {

		auditRecord := models2.AuditFile{
			FileID:         file.ID,
			SubscriptionID: "Authenticated ID",
			Source:         frame.GetIp(r),
			Action:         "View",
		}
		service.DB(ctx, false).Create(&auditRecord)
	}()

	w.Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=%s", file.Name))
	w.Header().Set("Content-Type", file.Mimetype)
	http.ServeContent(w, r, file.Name, file.CreatedAt, bytes.NewReader(fileContent))
	return nil
}

// FindFilesV1 -
func FindFilesV1(w http.ResponseWriter, r *http.Request) error {
	ctx := r.Context()
	service := frame.FromContext(ctx)

	var matchingFiles []models2.File

	subscriptionID := r.FormValue("subscription_id")
	groupID := r.FormValue("group_id")
	pageStr := r.FormValue("page")
	limitStr := r.FormValue("limit")

	tx := service.DB(ctx, true).Where("subscription_id = ?", subscriptionID)

	if groupID != "" {
		tx = tx.Where("group_id = ?", groupID)
	}

	page, err := strconv.Atoi(pageStr)
	if err != nil {
		page = 0
	}
	tx = tx.Offset(page)

	limit, err := strconv.Atoi(limitStr)
	if err != nil {
		limit = 30
	}
	tx = tx.Limit(limit)

	tx.Find(&matchingFiles)

	apiFiles := make([]openapi.File, len(matchingFiles))

	fileAccessServer := frame.GetEnv("FILE_ACCESS_SERVER_URL", "")
	for i, file := range matchingFiles {

		apiFiles[i] = file.ToApi(fileAccessServer)
	}

	response, _ := json.Marshal(apiFiles)

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	_, err = w.Write(response)
	if err != nil {
		return StatusError{500, err}
	}
	return nil
}
