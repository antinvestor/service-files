/*
 * Ant Investor Files
 *
 * An openAPI 3.0 specification that defines how files are stored and accessed on ant investor products
 *
 * API version: 1.0.0
 * Contact: info@antinvestor.com
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package service

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/antinvestor/files/config"
	"github.com/antinvestor/files/models"
	"github.com/antinvestor/files/openapi"
	"github.com/antinvestor/files/service/storage"
	"github.com/gorilla/mux"
	"github.com/opentracing/opentracing-go"
	"github.com/opentracing/opentracing-go/ext"
	"github.com/pitabwire/frame"
	"github.com/thedevsaddam/govalidator"
	"io/ioutil"
	"log"
	"net/http"
	"strconv"
	"strings"
)

func addHandler(service *frame.Service, storageProvider storage.Provider, router *mux.Router,
	f func(w http.ResponseWriter, r *http.Request) error, path string, name string, method string) {

	handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {

		r = r.WithContext(frame.ToContext(r.Context(), service))
		r = r.WithContext(context.WithValue(r.Context(), config.CtxBundleKey, service.Bundle()))
		r = r.WithContext(context.WithValue(r.Context(), config.CtxStorageProviderKey, storageProvider))

		err := f(w, r)
		if err != nil {
			switch e := err.(type) {
			case Error:
				// We can retrieve the status here and write out a specific
				// HTTP status code.
				log.Printf("request failed with  %d - %v", e.Status(), e)
				http.Error(w, e.Error(), e.Status())
			default:

				log.Printf(" request failed with - %v", e)
				// Any error types we don't specifically look out for default
				// to serving a HTTP 500
				http.Error(w, http.StatusText(http.StatusInternalServerError),
					http.StatusInternalServerError)
			}
		}

	})

	router.Methods(method).
		Path(path).
		Name(name).
		Handler(handler)

}

// NewRouterV1 -
func NewRouterV1(service *frame.Service) *mux.Router {

	storageProviderName := frame.GetEnv("STORAGE_PROVIDER", "LOCAL")
	storageProvider := storage.GetStorageProvider(storageProviderName)

	router := mux.NewRouter().StrictSlash(true)

	addHandler(service, storageProvider, router, AddFileV1, "/files", "AddFile", "POST")
	addHandler(service, storageProvider, router, FindFilesV1, "/files", "FindFiles", "GET")
	addHandler(service, storageProvider, router, FindFileByIDV1, "/files/{id}", "FindFileById", "GET")
	addHandler(service, storageProvider, router, DeleteFileV1, "/files/{id}", "DeleteFile", "DELETE")

	return router
}

// AddFileV1 -
func AddFileV1(w http.ResponseWriter, r *http.Request) error {

	service := frame.FromContext(r.Context())

	span, ctx := opentracing.StartSpanFromContext(r.Context(), "AddFileV1")
	defer span.Finish()

	rules := govalidator.MapData{
		"group_id":        []string{"required", "max:30"},
		"subscription_id": []string{"required", "max:30"},
		"public":          []string{"bool"},
		"file:fileObject": []string{"ext:jpeg,jpg,png", "size:100000000", "required"},
	}

	messages := govalidator.MapData{
		"group_id":        []string{"required: A group ID should be provided", "max:ID values should not be more than 30 characters in length"},
		"subscription_id": []string{"required: A subscription ID should be provided", "max:ID values should not be more than 30 characters in length"},
		"file:fileObject": []string{"ext:Only jpg/png files are allowed", "required:A file object is required"},
	}

	opts := govalidator.Options{
		Request:         r,        // request object
		Rules:           rules,    // rules map
		Messages:        messages, // custom message map (Optional)
		RequiredDefault: true,     // all the field to be pass the rules
	}
	validator := govalidator.New(opts)

	e := validator.Validate()
	if len(e) != 0 {
		err, _ := json.Marshal(e)
		return StatusError{400, errors.New(string(err))}
	}
	if err := r.ParseMultipartForm(262144); err != nil {
		return StatusError{400, err}
	}

	file, header, err := r.FormFile("fileObject")
	if err != nil {
		return StatusError{400, err}
	}

	contents, _ := ioutil.ReadAll(file)

	// Use the net/http package's handy DectectContentType function. Always returns a valid
	// content-type by returning "application/octet-stream" if no others seemed to match.
	contentType := http.DetectContentType(contents)

	// TODO: obtain the subscription id from authentication data
	subscriptionID := r.FormValue("subscription_id")

	groupID := r.FormValue("group_id")
	public, _ := strconv.ParseBool(r.FormValue("public"))

	hash := CreateHash(contents)

	extParts := strings.Split(header.Filename, ".")
	extension := extParts[len(extParts)-1]

	bucket, result, err := FileUpload(ctx, span.Context(), public, subscriptionID, hash, extension, contents)
	if err != nil {
		ext.Error.Set(span, true) // Tag the span as errored
		span.LogKV("Error on file upload", err)
		return StatusError{500, err}
	}

	storageProvider := ctx.Value(config.CtxStorageProviderKey).(storage.Provider)

	newFile := models.File{
		Name:           header.Filename,
		GroupID:        groupID,
		SubscriptionID: subscriptionID,
		Public:         public,
		Hash:           hash,
		Mimetype:       contentType,
		Ext:            extension,
		Size:           header.Size,
		BucketName:     bucket,
		Provider:       storageProvider.Name(),
		UploadResult:   result,
	}

	if err := service.DB(ctx, false).Create(&newFile).Error; err != nil {
		return StatusError{500, err}
	}

	fileAccessServer := frame.GetEnv("FILE_ACCESS_SERVER_URL", "")

	response, _ := json.Marshal(newFile.ToApi(fileAccessServer))

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusCreated)
	_, err = w.Write(response)
	if err != nil {
		return StatusError{500, err}
	}
	return nil

}

// DeleteFileV1 -
func DeleteFileV1(w http.ResponseWriter, r *http.Request) error {

	service := frame.FromContext(r.Context())

	span, ctx := opentracing.StartSpanFromContext(r.Context(), "DeleteFileV1")
	defer span.Finish()

	pathVars := mux.Vars(r)

	file := models.File{}

	if err := service.DB(ctx, true).First(&file, pathVars["id"]).Error; err != nil {
		return StatusError{500, err}
	}

	if err := service.DB(ctx, false).Delete(&file, pathVars["id"]).Error; err != nil {
		return StatusError{500, err}
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusAccepted)
	return nil
}

// FindFileByIDV1 -
func FindFileByIDV1(w http.ResponseWriter, r *http.Request) error {

	service := frame.FromContext(r.Context())

	span, ctx := opentracing.StartSpanFromContext(r.Context(), "FindFileByIDV1")
	defer span.Finish()

	pathVars := mux.Vars(r)

	file := models.File{}

	if err := service.DB(ctx, true).First(&file, pathVars["id"]).Error; err != nil {
		log.Printf("Could not find entry : %v", err)
	}

	fileContent, err := FileDownload(ctx, span.Context(), file)
	if err != nil {
		ext.Error.Set(span, true) // Tag the span as errored
		span.LogKV("Error on file download", err)

		return StatusError{500, err}
	}

	go func() {

		auditRecord := models.AuditFile{
			FileID:         file.ID,
			SubscriptionID: "Authenticated ID",
			Source:         frame.GetIp(r),
			Action:         "View",
		}
		service.DB(ctx, false).Create(&auditRecord)
	}()

	w.Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=%s", file.Name))
	w.Header().Set("Content-Type", file.Mimetype)
	http.ServeContent(w, r, file.Name, file.CreatedAt, bytes.NewReader(fileContent))
	return nil
}

// FindFilesV1 -
func FindFilesV1(w http.ResponseWriter, r *http.Request) error {

	service := frame.FromContext(r.Context())

	span, ctx := opentracing.StartSpanFromContext(r.Context(), "FindFilesV1")
	defer span.Finish()

	var matchingFiles []models.File

	subscriptionID := r.FormValue("subscription_id")
	groupID := r.FormValue("group_id")
	pageStr := r.FormValue("page")
	limitStr := r.FormValue("limit")

	tx := service.DB(ctx, true).Where("subscription_id = ?", subscriptionID)

	if groupID != "" {
		tx = tx.Where("group_id = ?", groupID)
	}

	page, err := strconv.Atoi(pageStr)
	if err != nil {
		page = 0
	}
	tx = tx.Offset(page)

	limit, err := strconv.Atoi(limitStr)
	if err != nil {
		limit = 30
	}
	tx = tx.Limit(limit)

	tx.Find(&matchingFiles)

	apiFiles := make([]openapi.File, len(matchingFiles))

	fileAccessServer := frame.GetEnv("FILE_ACCESS_SERVER_URL", "")
	for i, file := range matchingFiles {

		apiFiles[i] = file.ToApi(fileAccessServer)
	}

	response, _ := json.Marshal(apiFiles)

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	_, err = w.Write(response)
	if err != nil {
		return StatusError{500, err}
	}
	return nil
}
