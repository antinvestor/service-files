/*
 * Ant Investor Files
 *
 * An openAPI 3.0 specification that defines how files are stored and accessed on ant investor products
 *
 * API version: 1.0.0
 * Contact: info@antinvestor.com
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"context"
	"fmt"
	"github.com/antinvestor/files/config"
	"github.com/antinvestor/files/service/business"
	"github.com/antinvestor/files/service/business/storage"
	"github.com/antinvestor/files/service/models"
	"github.com/antinvestor/files/service/repository"
	"github.com/antinvestor/files/service/utils"
	"github.com/pitabwire/frame"
	"io/ioutil"
	"net/http"
	"os"
	"strings"
)

type downloadObject struct {
	file    *models.File
	content []byte
}

// ApiV1Service is a service that implents the logic for the DefaultApiServicer
// This service should implement the business logic for every endpoint for the DefaultApi API.
type ApiV1Service struct {
	service *frame.Service
	Storage storage.Provider
}

// NewApiV1Service creates a v1 api service
func NewApiV1Service(service *frame.Service, storageProvider storage.Provider) DefaultApiServicer {
	return &ApiV1Service{service: service, Storage: storageProvider}
}

func FileToApi(fileAccessServer string, file *models.File) File {

	fileUrl := fmt.Sprintf("%s/%s", fileAccessServer, file.ID)

	return File{
		Id:       file.ID,
		Name:     file.Name,
		Public:   file.Public,
		GroupId:  file.GroupID,
		AccessId: file.AccessID,
		Url:      fileUrl,
	}
}

// AddFile -
func (a *ApiV1Service) AddFile(ctx context.Context, groupId string, accessId string, public bool, name string, fileObject *os.File) (ImplResponse, error) {

	authClaim := frame.ClaimsFromContext(ctx)
	if authClaim != nil && authClaim.AccessID != "" {
		accessId = authClaim.AccessID
	}

	fiStat, err := fileObject.Stat()
	if err != nil {
		return Response(http.StatusInternalServerError, nil), err
	}

	contents, err := ioutil.ReadAll(fileObject)
	if err != nil {
		return Response(http.StatusInternalServerError, nil), err
	}

	// Use the net/http package's handy DectectContentType function. Always returns a valid
	// content-type by returning "application/octet-stream" if no others seemed to match.
	contentType := http.DetectContentType(contents)

	hash := utils.CreateHash(contents)

	extParts := strings.Split(name, ".")
	extension := extParts[len(extParts)-1]

	bucket, result, err := business.FileUpload(ctx, a.Storage, public, accessId, hash, extension, contents)
	if err != nil {
		return Response(http.StatusInternalServerError, nil), err
	}

	newFile := models.File{
		Name:         name,
		GroupID:      groupId,
		AccessID:     accessId,
		Public:       public,
		Hash:         hash,
		Mimetype:     contentType,
		Ext:          extension,
		Size:         fiStat.Size(),
		BucketName:   bucket,
		Provider:     a.Storage.Name(),
		UploadResult: result,
	}

	newFile.GenID()

	err = a.service.Publish(ctx, config.QueueFileSyncName, newFile)
	if err != nil {
		return Response(http.StatusInternalServerError, nil), err
	}

	fileAccessServer := frame.GetEnv(config.EnvFileAccessServerUrl, "")
	responseFile := FileToApi(fileAccessServer, &newFile)

	err = os.Remove(fileObject.Name())
	if err != nil {
		return Response(http.StatusInternalServerError, nil), err
	}

	return Response(http.StatusCreated, responseFile), nil
}

// DeleteFile - 
func (a *ApiV1Service) DeleteFile(ctx context.Context, id string) (ImplResponse, error) {

	fileRepository := repository.NewFileRepository(a.service)
	err := fileRepository.Delete(ctx, id)
	if err != nil {
		return Response(http.StatusInternalServerError, nil), err
	}

	return Response(http.StatusAccepted, nil), nil
}

// FindFileById - 
func (a *ApiV1Service) FindFileById(ctx context.Context, id string) (ImplResponse, error) {

	authClaim := frame.ClaimsFromContext(ctx)

	accessId := ""
	if authClaim != nil {
		accessId = authClaim.AccessID
	}

	fileRepository := repository.NewFileRepository(a.service)
	file, err := fileRepository.GetByID(ctx, id)
	if err != nil {
		return Response(http.StatusInternalServerError, nil), err
	}

	//TODO: Assign source a trace ID or something that can be used later to get more information
	//about this particular request
	auditRecord := models.FileAudit{
		FileID:   file.ID,
		AccessID: accessId,
		Source:   "frame.GetIp(r)",
		Action:   "View",
	}
	auditRecord.GenID()

	err = a.service.Publish(ctx, config.QueueFileAuditSyncName, auditRecord)
	if err != nil {
		return Response(http.StatusInternalServerError, nil), err
	}

	fileContent, err := business.FileDownload(ctx, a.Storage, file)
	if err != nil {
		return Response(http.StatusInternalServerError, nil), err
	}

	return Response(http.StatusOK, &downloadObject{file: file, content: fileContent}), nil
}

// FindFiles - 
func (a *ApiV1Service) FindFiles(ctx context.Context, subscriptionId string, groupId string, page int32, limit int32) (ImplResponse, error) {

	fileRepository := repository.NewFileRepository(a.service)

	matchingFiles, err := fileRepository.GetBySubscriptionAndGroup(ctx, subscriptionId, groupId, page, limit)
	if err != nil {
		return Response(http.StatusInternalServerError, nil), err
	}
	apiFiles := make([]File, len(matchingFiles))

	fileAccessServer := frame.GetEnv(config.EnvFileAccessServerUrl, "")
	for i, file := range matchingFiles {
		apiFiles[i] = FileToApi(fileAccessServer, file)
	}

	return Response(http.StatusOK, apiFiles), nil
}
