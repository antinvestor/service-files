/*
 * Ant Investor Files
 *
 * An openAPI 3.0 specification that defines how files are stored and accessed on ant investor products
 *
 * API version: 1.0.0
 * Contact: info@antinvestor.com
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"context"
	"fmt"
	"github.com/antinvestor/service-files/config"
	"github.com/antinvestor/service-files/service/business"
	"github.com/antinvestor/service-files/service/business/storage_provider"
	"github.com/antinvestor/service-files/service/events"
	"github.com/antinvestor/service-files/service/storage/models"
	"github.com/antinvestor/service-files/service/storage/repository"
	"github.com/antinvestor/service-files/service/types"
	"github.com/antinvestor/service-files/service/utils"
	"github.com/pitabwire/frame"
	"io"
	"net/http"
	"os"
	"strings"
)

type downloadObject struct {
	file    *models.MediaMetadata
	content []byte
}

// ApiV1Service is a service that implents the logic for the DefaultApiServicer
// This service should implement the business logic for every endpoint for the DefaultApi API.
type ApiV1Service struct {
	service *frame.Service
	Storage storage_provider.Provider
}

// NewApiV1Service creates a v1 api service
func NewApiV1Service(service *frame.Service, storageProvider storage_provider.Provider) DefaultApiServicer {
	return &ApiV1Service{service: service, Storage: storageProvider}
}

func FileToApi(fileAccessServer string, file *models.MediaMetadata) File {

	fileUrl := fmt.Sprintf("%s/%s", fileAccessServer, file.ID)

	return File{
		Id:       file.ID,
		Name:     file.Name,
		Public:   file.Public,
		GroupId:  file.OwnerID,
		AccessId: file.AccessID,
		Url:      fileUrl,
	}
}

// AddFile -
func (a *ApiV1Service) AddFile(ctx context.Context, groupId string, accessId string, public bool, name string, fileObject *os.File) (ImplResponse, error) {

	cfg := a.service.Config().(*config.FilesConfig)

	fiStat, err := fileObject.Stat()
	if err != nil {
		return Response(http.StatusInternalServerError, nil), err
	}

	contents, err := io.ReadAll(fileObject)
	if err != nil {
		return Response(http.StatusInternalServerError, nil), err
	}

	// Use the net/http package's handy DectectContentType function. Always returns a valid
	// content-type by returning "application/octet-stream" if no others seemed to match.
	contentType := http.DetectContentType(contents)

	hash := utils.CreateHash(contents)

	extParts := strings.Split(name, ".")
	extension := extParts[len(extParts)-1]

	bucket, result, err := business.FileUpload(ctx, a.Storage, cfg.EnvStorageEncryptionPhrase, public, accessId, hash, extension, contents)
	if err != nil {
		return Response(http.StatusInternalServerError, nil), err
	}

	properties := frame.DBPropertiesFromMap(map[string]string{
		"res": result,
	})

	newMedia := models.MediaMetadata{
		Name:       name,
		OwnerID:    groupId,
		Public:     public,
		Hash:       hash,
		Mimetype:   contentType,
		Ext:        extension,
		Size:       fiStat.Size(),
		BucketName: bucket,
		Provider:   a.Storage.Name(),
		Properties: properties,
	}

	newMedia.GenID(ctx)

	metadataSaveEvent := events.MediaMetadataSaveEvent{}
	err = a.service.Emit(ctx, metadataSaveEvent.Name(), newMedia)
	if err != nil {
		return Response(http.StatusInternalServerError, nil), err
	}

	responseFile := FileToApi(cfg.FileAccessServerUrl, &newMedia)

	err = os.Remove(fileObject.Name())
	if err != nil {
		return Response(http.StatusInternalServerError, nil), err
	}

	return Response(http.StatusCreated, responseFile), nil
}

// DeleteFile -
func (a *ApiV1Service) DeleteFile(ctx context.Context, id string) (ImplResponse, error) {

	fileRepository := repository.NewMediaRepository(a.service)
	err := fileRepository.Delete(ctx, types.MediaID(id))
	if err != nil {
		return Response(http.StatusInternalServerError, nil), err
	}

	return Response(http.StatusAccepted, nil), nil
}

// FindFileById -
func (a *ApiV1Service) FindFileById(ctx context.Context, id string) (ImplResponse, error) {

	authClaim := frame.ClaimsFromContext(ctx)
	cfg := a.service.Config().(*config.FilesConfig)

	accessId := ""
	if authClaim != nil {
		accessId = authClaim.GetAccessId()
	}

	fileRepository := repository.NewMediaRepository(a.service)
	file, err := fileRepository.GetByID(ctx, types.MediaID(id))
	if err != nil {
		return Response(http.StatusInternalServerError, nil), err
	}

	//TODO: Assign source a trace ID or something that can be used later to get more information
	//about this particular request
	auditRecord := models.MediaAudit{
		FileID:   file.ID,
		AccessID: accessId,
		Source:   "frame.GetIp(r)",
		Action:   "View",
	}
	auditRecord.GenID(ctx)

	auditSaveEvent := events.MediaAuditSaveEvent{}
	err = a.service.Emit(ctx, auditSaveEvent.Name(), auditRecord)
	if err != nil {
		return Response(http.StatusInternalServerError, nil), err
	}

	fileContent, err := business.FileDownload(ctx, a.Storage, cfg.EnvStorageEncryptionPhrase, file)
	if err != nil {
		return Response(http.StatusInternalServerError, nil), err
	}

	return Response(http.StatusOK, &downloadObject{file: file, content: fileContent}), nil
}

// FindFiles -
func (a *ApiV1Service) FindFiles(ctx context.Context, ownerId string, query string, page int32, limit int32) (ImplResponse, error) {

	cfg := a.service.Config().(*config.FilesConfig)
	fileRepository := repository.NewMediaRepository(a.service)

	matchingFiles, err := fileRepository.GetByOwnerID(ctx, types.OwnerID(ownerId), query, page, limit)
	if err != nil {
		return Response(http.StatusInternalServerError, nil), err
	}
	apiFiles := make([]File, len(matchingFiles))

	for i, file := range matchingFiles {
		apiFiles[i] = FileToApi(cfg.FileAccessServerUrl, file)
	}

	return Response(http.StatusOK, apiFiles), nil
}
