/*
 * Ant Investor Files
 *
 * An openAPI 3.0 specification that defines how files are stored and accessed on ant investor products
 *
 * API version: 1.0.0
 * Contact: info@antinvestor.com
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"crypto/sha512"
	"encoding/hex"
	"encoding/json"
	"io/ioutil"
	"net/http"
	"os"
	"path/filepath"
	"strings"

	"github.com/Sirupsen/logrus"
	"github.com/gorilla/mux"
	"github.com/jinzhu/gorm"
	"github.com/thedevsaddam/govalidator"
)

func addHandler(db *gorm.DB, logger *logrus.Entry, router *mux.Router,
	f func(db *gorm.DB, logger *logrus.Entry, w http.ResponseWriter, r *http.Request), path string, name string, method string) {
	handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { f(db, logger, w, r) })
	loggedHandler := Logger(handler, name, logger)

	router.Methods(method).
		Path(path).
		Name(name).
		Handler(loggedHandler)

}

// NewRouterV1 -
func NewRouterV1(db *gorm.DB, logger *logrus.Entry) *mux.Router {
	router := mux.NewRouter().StrictSlash(true)

	addHandler(db, logger, router, AddFileV1, "/files", "AddFile", "POST")
	addHandler(db, logger, router, FindFilesV1, "/files", "FindFiles", "GET")
	addHandler(db, logger, router, FindFileByIDV1, "/files/{id}", "FindFileById", "GET")
	addHandler(db, logger, router, DeleteFileV1, "/files/{id}", "DeleteFile", "DELETE")

	return router
}

// AddFileV1 -
func AddFileV1(db *gorm.DB, logger *logrus.Entry, w http.ResponseWriter, r *http.Request) {

	uploadDirectory := os.Getenv("UPLOAD_DIRECTORY")

	rules := govalidator.MapData{
		"group_id":        []string{"required", "max:30"},
		"subscription_id": []string{"required", "max:30"},
		"public":          []string{"boolean"},
		"file:fileObject": []string{"ext:jpg,png", "size:100000000", "required"},
	}

	messages := govalidator.MapData{
		"group_id":        []string{"required: A group ID should be provided", "max:ID values should not be more than 30 characters in length"},
		"subscription_id": []string{"required: A subscription ID should be provided", "max:ID values should not be more than 30 characters in length"},
		"file:fileObject": []string{"ext:Only jpg/png files are allowed", "required:A file object is required"},
	}

	opts := govalidator.Options{
		Request:         r,        // request object
		Rules:           rules,    // rules map
		Messages:        messages, // custom message map (Optional)
		RequiredDefault: true,     // all the field to be pass the rules
	}
	validator := govalidator.New(opts)

	e := validator.Validate()
	if e != nil {
		err := map[string]interface{}{"code": 400, "message": e}
		w.Header().Set("Content-type", "application/json")
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(err)
		return
	}
	if err := r.ParseMultipartForm(262144); err != nil {
		logger.Warningf("Error parsing supplied file : %v", err)
		return
	}

	file, header, err := r.FormFile("fileObject")
	if err != nil {
		logger.Warning(err)
		return
	}

	contents, _ := ioutil.ReadAll(file)

	hasher := sha512.New()
	hasher.Write(contents)
	hash := hex.EncodeToString(hasher.Sum(nil))

	extParts := strings.Split(header.Filename, ".")
	ext := extParts[len(extParts)-1]

	filename := filepath.Join(uploadDirectory, hash+"."+ext)

	err = ioutil.WriteFile(filepath.Join(uploadDirectory, hash+"."+ext), contents, 0644)
	if err != nil {
		logger.Warn(err)
		return
	}

	response := map[string]interface{}{
		"filename": "/" + filename,
	}

	json.NewEncoder(w).Encode(response)

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)

}

// DeleteFileV1 -
func DeleteFileV1(db *gorm.DB, logger *logrus.Entry, w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

// FindFileByIDV1 -
func FindFileByIDV1(db *gorm.DB, logger *logrus.Entry, w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

// FindFilesV1 -
func FindFilesV1(db *gorm.DB, logger *logrus.Entry, w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}
